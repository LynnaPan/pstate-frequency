#!/bin/sh

# The MIT License (MIT)
#
# Copyright (c) 2016 Peter Kenji Yamanaka
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# pstate-frequency
# by: pyamsoft <pyam(dot)soft(at)gmail(dot)com>
readonly version="3.0.0"

# Exit codes
# 0 - Success
# 1 - Missing Binary
# 2 - Invalid option

# Options that do not handle an argument
display_help=0
display_version=0

execution_delay=0 # Number of seconds to delay script
execution_sleep=0 # Number of seconds to sleep in between setting values

# Options that expect an argument

# Log levels
readonly mask_log_level_off=0
readonly mask_log_level_quiet=1
readonly mask_log_level_normal=2
readonly mask_log_level_verbose=3
readonly mask_log_level_all=4
log_level="${mask_log_level_normal}"

# Execution modes
# 0000 = 0 -> HELP
# 0001 = 1 -> VERSION
# 0010 = 2 -> GET
# 0100 = 4 -> SET
readonly mask_mode_help=0
readonly mask_mode_version=1
readonly mask_mode_get=2
readonly mask_mode_set=3
mode="${mask_mode_help}"

# Get bitmask
# 0000 = 0 -> CURRENT
# 0001 = 1 -> REAL
readonly mask_get_type_current=0
readonly mask_get_type_real=1
get_type="${mask_get_type_current}"

# Set bitmask
set_max=0
set_min=0
set_turbo=0
set_governor=0

# Supported option flags
#
# -H | --help
# -V | --version
# -G | --get
# -S | --set
#
# -p | --plan
# -m | --max
# -n | --min
# -t | --turbo
# -g | --governor
#
# -c | --current
# -r | --real
#
# -d | --debug
# -q | --quiet
#
# --delay
# --color
# --sleep

# Normal log
# Can be seen at
# log_level = normal, verbose, all
log()
{
  if [ "${log_level}" -ge "${mask_log_level_normal}" ]; then
    printf -- "$@\n"
  fi
}

# Verbose log
# Can be seen at
# log_level = verbose, all
log_verbose()
{
  if [ "${log_level}" -ge "${mask_log_level_verbose}" ]; then
    printf -- "DEBUG: $@\n"
  fi
}

# All log
# Can be seen at
# log_level = all
log_all()
{
  if [ "${log_level}" -eq "${mask_log_level_all}" ]; then
    printf -- "VERBOSE: $@\n"
  fi
}

# Quiet log
# Can be seen at
# log_level = quiet, normal, verbose, all
log_quiet()
{
  if [ "${log_level}" -ge "${mask_log_level_quiet}" ]; then
    printf -- "$@\n"
  fi
}

# Error logging
elog()
{
  log "$@" 1>&2
}

elog_verbose()
{
  log_verbose "$@" 1>&2
}

elog_all()
{
  log_all "$@" 1>&2
}

elog_quiet()
{
  log_quiet "$@" 1>&2
}

# Check the environment path for the given binary, exit if it is not found
check_binary()
{
  if ! which "$1" > /dev/null 2>&1; then
    log_quiet "The '$1' binary is required for operation of this script."
    log_quiet "Please install '$1' onto your system."
    exit 1
  fi
}

print_usage()
{
  log "usage:"
  log "pstate-frequency [verbose] [ACTION] [option(s)]"
  log
  log "verbose:"
  log "    unprivileged:"
  log "    -d | --debug     Print debugging messages to stdout (multiple)"
  log "    -q | --quiet     Supress all non-error output (multiple)"
  log "    --color          Colorize output"
  log
  log
  log "actions:"
  log "    unprivileged:"
  log "    -H | --help      Display this help and exit"
  log "    -V | --version   Display application version and exit"
  log "    -G | --get       Access current CPU values"
  log "    --delay          Delay execution by 5 seconds"
  log "    privileged:"
  log "    -S | --set       Modify current CPU values"
  log
  log
  log "options:"
  log "    unprivileged:"
  log "    -c | --current   Display the current user set CPU values"
  log "    -r | --real      Display the real time CPU frequencies"
  log "    privileged:"
  log "    -p | --plan      Set a predefined power plan"
  log "    -m | --max       Modify current CPU max frequency"
  log "    -g | --governor  Set the cpufreq governor"
  log "    -n | --min       Modify current CPU min frequency"
  log "    -t | --turbo     Modify curent CPU turbo boost state"
  log "    --sleep          Sleep before setting CPU frequencies"
}

print_version()
{
  log_quiet "pstate-frequency version ${version}"
}

log_more_verbose()
{
  if [ "${log_level}" -lt "${mask_log_level_all}" ]; then
    log_level=$((${log_level} + 1))
    log_all "log_level more verbose"
  fi
}

log_less_verbose()
{
  if [ "${log_level}" -gt "${mask_log_level_off}" ]; then
    log_all "log_level less verbose"
    log_level=$((${log_level} - 1))
  fi
}

handle_argument()
{
  if [ "$1" = '-' ]; then
    log_all "Skip '-' processing"
  elif [ -z "${option_expects_argument}" ]; then
    elog_verbose "option does not expect argument!"
    elog_verbose "argument: $1"
    elog_quiet "Illegal command $1"
    exit 2
  else
    log_verbose "option expects argument: ${option_expects_argument}"
    log_verbose "argument: $1"
  fi
}

# While risky to call eval, this is one way to
# emulate the bash indirect_expansion ability
option_expects_argument=""
eval optind_expanded="\$${OPTIND}"
while [ -n "${optind_expanded}" ]; do
  while getopts ":HVGSpmntgcrdq-:" option; do
    log_verbose "option: -${option}${OPTARG}"
    case "${option}" in
      -)
        case "${OPTARG}" in
          help)
            print_usage
            exit 0
            ;;
          version)
            print_version
            exit 0
            ;;
          get)
            option_expects_argument=""
            mode="${mask_mode_get}"
            ;;
          set)
            option_expects_argument=""
            mode="${mask_mode_set}"
            ;;
          plan)
            option_expects_argument="plan"
            ;;
          max)
            option_expects_argument="max"
            ;;
          min)
            option_expects_argument="min"
            ;;
          turbo)
            option_expects_argument="turbo"
            ;;
          governor)
            option_expects_argument="governor"
            ;;
          current)
            option_expects_argument=""
            ;;
          real)
            option_expects_argument=""
            ;;
          debug)
            option_expects_argument=""
            log_more_verbose
            ;;
          quiet)
            option_expects_argument=""
            log_less_verbose
            ;;
          delay)
            option_expects_argument=""
            ;;
          color)
            option_expects_argument=""
            ;;
          sleep)
            option_expects_argument=""
            ;;
          *)
            # We must provide our own error message in this case
            elog_quiet "Illegal option --${OPTARG}"
            print_usage
            exit 2
            ;;
        esac
        ;;
      H)
        print_usage
        exit 0
        ;;
      V)
        print_version
        exit 0
        ;;
      G)
        option_expects_argument=""
        ;;
      S)
        option_expects_argument=""
        ;;
      p)
        option_expects_argument="plan"
        ;;
      m)
        option_expects_argument="max"
        ;;
      n)
        option_expects_argument="min"
        ;;
      t)
        option_expects_argument="turbo"
        ;;
      g)
        option_expects_argument="governor"
        ;;
      c)
        option_expects_argument=""
        ;;
      r)
        option_expects_argument=""
        ;;
      d)
        option_expects_argument=""
        log_more_verbose
        ;;
      q)
        option_expects_argument=""
        log_less_verbose
        ;;
      *)
        elog_quiet "Illegal option ${optind_expanded}"
        print_usage
        exit 2
        ;;
    esac
  done

  # Re-establish the current OPTIND target
  eval optind_expanded="\$${OPTIND}"
  if [ -z "${optind_expanded}" ]; then
    break
  else
    # This is a plain arg and should be handled by one of the options which takes an argument
    handle_argument "${optind_expanded}"

    # Set back to null
    option_expects_argument=""
  fi

  # Shift the options
  shift $OPTIND
  OPTIND=1
done

case "${mode}" in
  "${mask_mode_get}")
    ;;
  "${mask_mode_set}")
    ;;
esac


# vim: set syntax=sh tabstop=2 softtabstop=2 shiftwidth=2 shiftround expandtab:

