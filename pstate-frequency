#!/bin/sh

# The MIT License (MIT)
#
# Copyright (c) 2016 Peter Kenji Yamanaka
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# pstate-frequency
# by: pyamsoft <pyam(dot)soft(at)gmail(dot)com>
readonly version="3.3.0"

# Exit codes
# 0 - Success
# 1 - Missing Binary
# 2 - Invalid option
# 3 - Wrong operation mode
# 4 - Invalid power plan
# 5 - Missing essential requirement
# 6 - Missing root

# Options that do not handle an argument
execution_delay=0 # Number of seconds to delay script
execution_sleep=0 # Number of seconds to sleep in between setting values

# Options that expect an argument

# Log levels
readonly const_log_level_off=0
readonly const_log_level_quiet=1
readonly const_log_level_normal=2
readonly const_log_level_verbose=3
readonly const_log_level_all=4
log_level="${const_log_level_normal}"

# Execution modes
readonly const_mode_none=0
readonly const_mode_get=1
readonly const_mode_set=2
mode="${const_mode_none}"

# Get modes
readonly const_get_type_current=0
readonly const_get_type_real=1
get_type="${const_get_type_current}"

# Set commands
readonly const_set_max_false=0
readonly const_set_max_true=1
set_max_type="${const_set_max_false}"
set_max_arg=""

readonly const_set_min_false=0
readonly const_set_min_true=1
set_min_type="${const_set_min_false}"
set_min_arg=""

readonly const_set_turbo_false=0
readonly const_set_turbo_true=1
set_turbo_type="${const_set_turbo_false}"
set_turbo_arg=""

readonly const_set_governor_false=0
readonly const_set_governor_true=1
set_governor_type="${const_set_governor_false}"
set_governor_arg=""

# Plan modes
readonly const_power_plan_auto=0
readonly const_power_plan_powersave=1
readonly const_power_plan_balanced=2
readonly const_power_plan_performance=3
readonly const_power_plan_max=4

# X86_perf_policy levels
readonly const_set_x86_policy_false=0
readonly const_set_x86_policy_true=1
readonly const_x86_policy_powersave=0
readonly const_x86_policy_normal=1
readonly const_x86_policy_performance=2
set_x86_policy_type=""
set_x86_policy_arg=""

# Supported option flags
#
# -H | --help
# -V | --version
# -G | --get
# -S | --set
#
# -p | --plan
# -m | --max
# -n | --min
# -t | --turbo
# -g | --governor
#
# -c | --current
# -r | --real
#
# -d | --debug
# -q | --quiet
#
# --delay
# --sleep

# Normal log
# Can be seen at
# log_level = normal, verbose, all
log()
{
  if [ "${log_level}" -ge "${const_log_level_normal}" ]; then
    printf -- "$@\n"
  fi
}

# Verbose log
# Can be seen at
# log_level = verbose, all
log_verbose()
{
  if [ "${log_level}" -ge "${const_log_level_verbose}" ]; then
    printf -- "VERBOSE: $@\n"
  fi
}

# All log
# Can be seen at
# log_level = all
log_all()
{
  if [ "${log_level}" -eq "${const_log_level_all}" ]; then
    printf -- "DEBUG: $@\n"
  fi
}

# Quiet log
# Can be seen at
# log_level = quiet, normal, verbose, all
log_quiet()
{
  if [ "${log_level}" -ge "${const_log_level_quiet}" ]; then
    printf -- "$@\n"
  fi
}

# Error logging
elog()
{
  log "ERROR: $@" 1>&2
}

# Verbose error logging
elog_verbose()
{
  log_verbose "ERROR: $@" 1>&2
}

# All error logging
elog_all()
{
  log_all "ERROR: $@" 1>&2
}

# Quiet error logging
elog_quiet()
{
  log_quiet "ERROR: $@" 1>&2
}

# Check the environment path for the given binary, exit if it is not found
check_binary()
{
  if [ -z "$1" ]; then
    elog_quiet "Must specify a path to a binary"
    return 1
  fi

  local IFS=":"
  for part in ${PATH}; do
    local check="${part}/$1"
    if [ -e "${check}" ]; then
      unset check
      return 0
    fi
    unset check
  done

  elog_quiet "Binary '$1' not found in \$PATH"
  return 1
}

# Print usage
print_usage()
{
  log "usage:"
  log "pstate-frequency [verbose] [ACTION] [option(s)]"
  log
  log "verbose:"
  log "    unprivileged:"
  log "    -d | --debug     Print debugging messages to stdout (multiple)"
  log "    -q | --quiet     Supress all non-error output (multiple)"
  log
  log
  log "actions:"
  log "    unprivileged:"
  log "    -H | --help      Display this help and exit"
  log "    -V | --version   Display application version and exit"
  log "    -G | --get       Access current CPU values"
  log "    --delay          Delay execution by 5 seconds"
  log "    privileged:"
  log "    -S | --set       Modify current CPU values"
  log
  log
  log "options:"
  log "    unprivileged:"
  log "    -c | --current   Display the current user set CPU values"
  log "    -r | --real      Display the real time CPU frequencies"
  log "    privileged:"
  log "    -p | --plan      Set a predefined power plan"
  log "    -m | --max       Modify current CPU max frequency"
  log "    -g | --governor  Set the cpufreq governor"
  log "    -n | --min       Modify current CPU min frequency"
  log "    -t | --turbo     Modify curent CPU turbo boost state"
  log "    --sleep          Sleep before setting CPU frequencies"
}

# Check if the passed in variable is digits
# Does not support negative numbers
is_digits()
{
  case "$1" in
    ([!0-9]*|'')
      printf -- 0
      ;;
    (*)
      printf -- 1
      ;;
  esac
}

# Print version
print_version()
{
  log "pstate-frequency version ${version}"
}

# Increase log verbosity
log_more_verbose()
{
  if [ "${log_level}" -lt "${const_log_level_all}" ]; then
    log_level=$((${log_level} + 1))
    log_all "log_level more verbose"
  fi
}

# Decrease log verbosity
log_less_verbose()
{
  if [ "${log_level}" -gt "${const_log_level_off}" ]; then
    log_all "log_level less verbose"
    log_level=$((${log_level} - 1))
  fi
}

# Guarantee the variable passed at $1
# is >= $2 and <= $3
# $1 is guaranteed to be a number
set_variable_bounds()
{
  if [ "$1" -lt "$2" ]; then
    printf -- "$2"
  elif [ "$1" -gt "$3" ]; then
    printf -- "$3"
  else
    printf -- "$1"
  fi
}

# Set the argument for cpu_max
# Can be set multiple times, final time overrides
set_max()
{
  log_verbose "set_max requires SET operation mode"
  if [ "${mode}" -eq "${const_mode_set}" ]; then
    local value=""
    log_verbose "Check for special case arguments: max, min"
    if [ "$1" = "max" ]; then
      log_verbose "Argument was 'max' set to ${const_system_cpu_max_value}"
      value="${const_system_cpu_max_value}"
    elif [ "$1" = "min" ]; then
      log_verbose "Argument was 'min' set to ${const_system_cpu_min_value}"
      value="${const_system_cpu_min_value}"
    else
      log_verbose "Argument was not special, read as is"
      value="$1"
    fi
    log_verbose "Check that '${value}' is all digits"
    if [ $(is_digits "${value}") -eq 1 ]; then
      log_verbose "'${value}' is all digits"
      local fixed_min="$(( ${const_system_cpu_min_value} + 1 ))"
      log_verbose "Bound value '${value}' between ${fixed_min} and ${const_system_cpu_max_value}"
      value="$(set_variable_bounds "${value}" ${fixed_min} ${const_system_cpu_max_value})"
      unset fixed_min
      set_max_type="${const_set_max_true}"
      set_max_arg="${value}"
      log_verbose "set_max_arg: '${set_max_arg}'"
    else
      elog_quiet "max argument '${value}' is not a number"
      unset value
      exit 2
    fi
    unset value
  else
    elog_quiet "Cannot set max outside of SET operation mode"
    exit 3
  fi
}

# Set the argument for cpu_min
# Can be set multiple times, final time overrides
set_min()
{
  log_verbose "set_min requires SET operation mode"
  if [ "${mode}" -eq "${const_mode_set}" ]; then
    local value=""
    log_verbose "Check for special case arguments: max, min"
    if [ "$1" = "max" ]; then
      log_verbose "Argument was 'max' set to ${const_system_cpu_max_value}"
      value="${const_system_cpu_max_value}"
    elif [ "$1" = "min" ]; then
      log_verbose "Argument was 'min' set to ${const_system_cpu_min_value}"
      value="${const_system_cpu_min_value}"
    else
      log_verbose "Argument was not special, read as is"
      value="$1"
    fi
    log_verbose "Check that '${value}' is all digits"
    if [ $(is_digits "${value}") -eq 1 ]; then
      log_verbose "'${value}' is all digits"
      local fixed_max="$(( ${const_system_cpu_max_value} - 1 ))"
      log_verbose "Bound value '${value}' between ${const_system_cpu_min_value} and ${fixed_max}"
      value="$(set_variable_bounds "${value}" ${const_system_cpu_min_value} ${fixed_max})"
      unset fixed_max
      set_min_type="${const_set_min_true}"
      set_min_arg="${value}"
      log_verbose "set_min_arg: '${set_min_arg}'"
    else
      elog_quiet "min argument '${value}' is not a number"
      unset value
      exit 2
    fi
    unset value
  else
    elog_quiet "Cannot set min outside of SET operation mode"
    exit 3
  fi
}

# Set the argument for cpu_turbo
# Can be set multiple times, final time overrides
set_turbo()
{
  log_verbose "set_turbo requires SET operation mode"
  if [ "${mode}" -eq "${const_mode_set}" ]; then
    local value=""
    log_verbose "Check for special case arguments: on, off"
    if [ "$1" = "on" ]; then
      log_verbose "Argument was 'on' set to 0"
      value="0"
    elif [ "$1" = "off" ]; then
      log_verbose "Argument was 'off' set to 1"
      value="1"
    else
      log_verbose "Argument was not special, read as is"
      value="$1"
    fi
    log_verbose "Check that '${value}' is all digits"
    if [ $(is_digits "${value}") -eq 1 ]; then
      log_verbose "'${value}' is all digits"
      log_verbose "Bound value '${value}' between 0 and 1"
      value="$(set_variable_bounds "${value}" 0 1)"
      set_turbo_type="${const_set_turbo_true}"
      set_turbo_arg="${value}"
      log_verbose "set_turbo_arg: '${set_turbo_arg}'"
    else
      elog_quiet "turbo argument '${value}' is not a number"
      unset value
      exit 2
    fi
    unset value
  else
    elog_quiet "Cannot set turbo outside of SET operation mode"
    exit 3
  fi
}

# Set the argument for cpu_governor
# Can be set multiple times, final time overrides
set_governor()
{
  log_verbose "set_governor requires SET operation mode"
  if [ "${mode}" -eq "${const_mode_set}" ]; then
    local value=""
    log_verbose "Check for special case arguments: powersave, performance"
    if [ "$1" = "0" ]; then
      log_verbose "Argument was '0' set to powersave"
      value="powersave"
    elif [ "$1" = "1" ]; then
      log_verbose "Argument was '1' set to performance"
      value="performance"
    else
      log_verbose "Argument was not special, read as is"
      value="$1"
    fi
    log_verbose "Check that '${value}' is not digits"
    if [ ! $(is_digits "${value}") -eq 1 ]; then
      log_verbose "'${value}' is not digits"
      if [ "${value}" != "powersave" ] && [ "${value}" != "performance" ]; then
        elog_quiet "Invalid governor specified, do not change"
      else
        set_governor_type="${const_set_governor_true}"
        set_governor_arg="${value}"
        log_verbose "set_governor_arg: '${set_governor_arg}'"
      fi
    else
      elog_quiet "governor argument '${value}' is a number"
      unset value
      exit 2
    fi
    unset value
  else
    elog_quiet "Cannot set governor outside of SET operation mode"
    exit 3
  fi
}

# Set the argument for x86_perf_policy
# Can be set multiple times, final time overrides
set_x86()
{
  log_verbose "set_x86 requires SET operation mode"
  if [ "${mode}" -eq "${const_mode_set}" ]; then
    local value=""
    log_verbose "Check for special case arguments: 0, 1, 2"
    if [ "$1" = "0" ]; then
      log_verbose "Argument was '0' set to powersave"
      value="powersave"
    elif [ "$1" = "1" ]; then
      log_verbose "Argument was '1' set to normal"
      value="normal"
    elif [ "$1" = "2" ]; then
      log_verbose "Argument was '2' set to performance"
      value="performance"
    else
      log_verbose "Argument was not special, read as is"
      value="$1"
    fi
    log_verbose "Check that '${value}' is not digits"
    if [ ! $(is_digits "${value}") -eq 1 ]; then
      log_verbose "'${value}' is not digits"
      if [ "${value}" = "none" ]; then
        log_verbose "x86_policy_arg: None requested. Reset values"
        set_x86_policy_type="${const_set_x86_policy_false}"
        set_x86_policy_arg=""
      elif [ "${value}" != "powersave" ] && [ "${value}" != "normal" ] && [ "${value}" != "performance" ]; then
        elog_quiet "Invalid x86_perf_policy specified, do not change"
      else
        set_x86_policy_type="${const_set_x86_policy_true}"
        set_x86_policy_arg="${value}"
        log_verbose "set_x86_policy_arg: '${set_x86_policy_arg}'"
      fi
    else
      elog_quiet "x86 argument '${value}' is a number"
      unset value
      exit 2
    fi
    unset value
  else
    elog_quiet "Cannot set x86 outside of SET operation mode"
    exit 3
  fi
}

# Set the power plan based on argument
set_power_plan()
{
  log_verbose "set_power_plan requires SET operation mode"
  if [ "${mode}" -eq "${const_mode_set}" ]; then
    local value=""
    log_verbose "Check for special case arguments: auto, powersave, balanced, performance, max"
    if [ "$1" = "auto" ]; then
      log_verbose "Argument was 'auto' set to ${const_power_plan_auto}"
      value="${const_power_plan_auto}"
    elif [ "$1" = "powersave" ]; then
      log_verbose "Argument was 'powersave' set to ${const_power_plan_powersave}"
      value="${const_power_plan_powersave}"
    elif [ "$1" = "balanced" ]; then
      log_verbose "Argument was 'balanced' set to ${const_power_plan_balanced}"
      value="${const_power_plan_balanced}"
    elif [ "$1" = "performance" ]; then
      log_verbose "Argument was 'performance' set to ${const_power_plan_performance}"
      value="${const_power_plan_performance}"
    elif [ "$1" = "max" ]; then
      log_verbose "Argument was 'max' set to ${const_power_plan_max}"
      value="${const_power_plan_max}"
    else
      log_verbose "Argument was not special, read as is"
      value="$1"
    fi
    log_verbose "Check that '${value}' is all digits"
    if [ $(is_digits "${value}") -eq 1 ]; then
      log_verbose "'${value}' is all digits"
      case "${value}" in
        "${const_power_plan_auto}")
          set_power_plan_auto
          ;;
        "${const_power_plan_powersave}")
          set_power_plan_powersave
          ;;
        "${const_power_plan_balanced}")
          set_power_plan_balanced
          ;;
        "${const_power_plan_performance}")
          set_power_plan_performance
          ;;
        "${const_power_plan_max}")
          set_power_plan_max
          ;;
        *)
          elog_quiet "Invalid power plan: ${value}"
          exit 4
          ;;
      esac
    else
      elog_quiet "power plan argument '${value}' is not a number"
      unset value
      exit 2
    fi
    unset value
  else
    elog_quiet "Cannot set power plan outside of SET operation mode"
    exit 3
  fi
}

# Check if the current power source is Mains
is_power_supply_mains()
{
  # For each power supply
  for power_supply in "${const_system_power_supply_dir}"/*; do
    # Get the power_supply type
    local type="$(cat ${power_supply}/type )"

    # Check if the type is Mains
    if [ "${type}" = "Mains" ]; then

      # If Mains, check if the online file exists
      if [ -e "${power_supply}"/online ]; then

        # If online exists, cat out the status
        cat -- "${power_supply}"/online
        return
      fi
    fi
  done

  # We did not find any power supply listed as Mains, print 0 for false
  printf -- 0

}

# Sets the power plan based on the current plugged in status
set_power_plan_auto()
{
  log_verbose "Set power plan to: auto"
  if [ $(is_power_supply_mains) -eq 1 ]; then
    set_power_plan_balanced
  else
    set_power_plan_powersave
  fi
}

# Sets the power plan to a low power mode
set_power_plan_powersave()
{
  log_verbose "Set power plan to: powersave"
  set_max 0
  set_min 0
  set_turbo 1
  set_governor 0
  set_x86 0
}

# Sets the power plan to a balanced mode
set_power_plan_balanced()
{
  log_verbose "Set power plan to: balanced"
  set_max 100
  set_min 0
  set_turbo 1
  set_governor 0
  set_x86 0
}

# Sets the power plan to a performance mode
set_power_plan_performance()
{
  log_verbose "Set power plan to: performance"
  set_max 100
  set_min 0
  set_turbo 0
  set_governor 1
  set_x86 1
}

# Sets the power plan to the max available performance mode
set_power_plan_max()
{
  log_verbose "Set power plan to: performance"
  set_max 100
  set_min 100
  set_turbo 0
  set_governor 1
  set_x86 2
}

# Handle long options which take arguments
handle_long_option_argument()
{
  if [ "$1" = '-' ]; then
    log_all "Skip '-' processing"
  elif [ -z "${option_expects_argument}" ]; then
    elog_verbose "option does not expect argument!"
    elog_verbose "argument: $1"
    elog_quiet "Illegal argument $1"
    exit 2
  else
    log_verbose "option expects argument: ${option_expects_argument}"
    log_verbose "argument: $1"

    case "${option_expects_argument}" in
      plan)
        log_verbose "Long option: plan"
        set_power_plan "$1"
        ;;
      max)
        log_verbose "Long option: max"
        set_max "$1"
        ;;
      min)
        log_verbose "Long option: min"
        set_min "$1"
        ;;
      turbo)
        log_verbose "Long option: turbo"
        set_turbo "$1"
        ;;
      governor)
        log_verbose "Long option: governor"
        set_governor "$1"
        ;;
      x86)
        log_verbose "Long option: x86"
        set_x86 "$1"
        ;;
      *)
        elog_quiet "Invalid option --${option_expects_argument}"
        exit 2
        ;;
    esac
  fi
}

do_get_current()
{
  local cpu_max_freq="$(cat "${const_system_scaling_max_freq}" )"
  local cpu_min_freq="$(cat "${const_system_scaling_min_freq}" )"
  local cpu_governor="$(cat "${const_system_scaling_governor}" )"
  local cpu_driver="$(cat "${const_system_scaling_driver}" )"

  local cpu_turbo
  if [ "${has_pstate_dir}" ]; then
    cpu_turbo="$(cat "${const_system_intel_pstate_turbo}" )"
  else
    cpu_turbo="$(cat "${const_system_cpufreq_boost}" )"
  fi

  local cpu_max_value=$(( ${cpu_max_freq} * 100 / ${const_system_cpu_max_freq} ))
  local cpu_min_value=$(( ${cpu_min_freq} * 100 / ${const_system_cpu_max_freq} ))

  local cpu_turbo_onoff=""
  if [ "${cpu_turbo}" -eq 1 ]; then
    cpu_turbo_onoff="OFF"
  else
    cpu_turbo_onoff="ON"
  fi

  print_version
  log "    pstate::CPU_DRIVER   -> ${cpu_driver}"
  log "    pstate::CPU_GOVERNOR -> ${cpu_governor}"
  log "    pstate::TURBO        -> ${cpu_turbo} [${cpu_turbo_onoff}]"
  log "    pstate::CPU_MIN      -> ${cpu_min_value}%% [${cpu_min_freq}KHz]"
  log "    pstate::CPU_MAX      -> ${cpu_max_value}%% [${cpu_max_freq}KHz]"

  unset cpu_turbo_onoff
  unset cpu_max_freq
  unset cpu_min_freq
  unset cpu_max_value
  unset cpu_min_value
  unset cpu_turbo
  unset cpu_governor
  unset cpu_driver
}

do_get_real()
{
  local real_freqs="$(grep MHz /proc/cpuinfo | cut -c12-)"
  local i=0

  print_version
  for freq in ${real_freqs}; do
    log "    pstate::CPU[$i]   -> ${freq}MHz"
    i=$(( $i + 1))
  done

  unset i
  unset real_freqs
}

do_get()
{
  case "${get_type}" in
    "${const_get_type_current}")
      do_get_current
      ;;
    "${const_get_type_real}")
      do_get_real
      ;;
    *)
      elog_quiet "Invalid GET type"
      exit 3
      ;;
  esac
}

root_do_set_has_arg()
{
  if [ "${set_max_type}" -eq 1 ] \
    || [ "${set_min_type}" -eq 1 ] \
    || [ "${set_turbo_type}" -eq 1 ] \
    || [ "${set_governor_type}" -eq 1 ]; then
    printf -- 1
  else
    printf -- 0
  fi
}

root_write_max()
{
  log_verbose "Write max_value '$1' to intel_pstate file: ${const_system_intel_pstate_max}"
  printf -- "$1" > "${const_system_intel_pstate_max}"
  log_all "Max value written to ${const_system_intel_pstate_max}"

  local max_freq=$(( $1 * ${const_system_cpu_max_freq} / 100 ))

  for i in $(seq 0 $(( ${const_system_cpu_number} - 1 )) ); do
    local target="${const_system_cpu_dir}/cpu${i}/cpufreq/scaling_max_freq"
    log_verbose "Write freq: ${max_freq}KHz to file: ${target}"
    printf -- "${max_freq}" > "${target}"
    log_all "Max value written to ${target}"
    unset target
  done

  unset max_freq
}

root_write_min()
{
  log_verbose "Write min_value '$1' to intel_pstate file: ${const_system_intel_pstate_min}"
  printf -- "$1" > "${const_system_intel_pstate_min}"
  log_all "Min value written to ${const_system_intel_pstate_min}"

  local min_freq=$(( $1 * ${const_system_cpu_max_freq} / 100 ))

  for i in $(seq 0 $(( ${const_system_cpu_number} - 1 )) ); do
    local target="${const_system_cpu_dir}/cpu${i}/cpufreq/scaling_min_freq"
    log_verbose "Write freq: ${min_freq}KHz to file: ${target}"
    printf -- "${min_freq}" > "${target}"
    log_all "Min value written to ${target}"
    unset target
  done

  unset max_freq
}

root_write_turbo()
{
  log_verbose "Write turbo_value '$1' to intel_pstate file: ${const_system_intel_pstate_turbo}"
  printf -- "$1" > "${const_system_intel_pstate_turbo}"
  log_all "Turbo value written to ${const_system_intel_pstate_turbo}"
}

root_write_governor()
{
  log_verbose "Write cpu_governor '$1' to all CPUs"
  for i in $(seq 0 $(( ${const_system_cpu_number} - 1 )) ); do
    local target="${const_system_cpu_dir}/cpu${i}/cpufreq/scaling_governor"
    log_verbose "Write governor: $1 to file: ${target}"
    printf -- "$1" > "${target}"
    log_all "Governor $1 written to ${target}"
    unset target
  done

  unset governor_name
}

root_write_x86_policy()
{
  if [ -n "$1" ]; then
    log_verbose "x86_perf_policy was requested: '$1'"
    local x86_bin="x86_energy_perf_policy"
    local x86_bin_result
    x86_bin_result=$(check_binary "${x86_bin}")
    if [ $? -eq 1 ]; then
      elog_quiet "Not setting x86_perf_policy even though it was requested"
    else
      log_verbose "Setting x86_perf_policy to '$1'"
      if [ "${log_level}" -ge "${const_log_level_verbose}" ]; then
      "${x86_bin}" -v "$1"
      else
      "${x86_bin}" "$1" > /dev/null
      fi
    fi
    unset x86_bin_result
    unset x86_bin
  else
    log_verbose "x86_perf_policy was not requested"
  fi
}

root_do_set()
{
  log_verbose "YOU ARE ROOT"
  log_verbose "Check that we are setting something"
  if [ "$(root_do_set_has_arg)" -eq 0 ]; then
    elog_quiet "Not setting any CPU options"
    exit 5
  fi

  local setting_cpu_max=""
  local setting_cpu_min=""
  local setting_cpu_turbo=""
  local setting_cpu_governor=""
  local setting_x86_policy=""

  local cpu_max_freq="$(cat "${const_system_scaling_max_freq}" )"
  local cpu_min_freq="$(cat "${const_system_scaling_min_freq}" )"
  local cpu_max_value=$(( ${cpu_max_freq} * 100 / ${const_system_cpu_max_freq} ))
  local cpu_min_value=$(( ${cpu_min_freq} * 100 / ${const_system_cpu_max_freq} ))
  local cpu_turbo="$(cat ${const_system_intel_pstate_turbo} )"
  local cpu_governor="$(cat ${const_system_scaling_governor} )"

  local sane_max="${const_system_cpu_max_value}"
  local sane_min="${const_system_cpu_min_value}"
  local sane_turbo=1
  local sane_governor="powersave"

  log_verbose "Check if we are setting max"
  if [ "${set_max_type}" -eq 1 ]; then
    log_verbose "Set max to arg"
    setting_cpu_max="${set_max_arg}"
  else
    log_verbose "Set max to current system"
    setting_cpu_max="${cpu_max_value}"
  fi

  log_verbose "Check if we are setting min"
  if [ "${set_min_type}" -eq 1 ]; then
    log_verbose "Set min to arg"
    setting_cpu_min="${set_min_arg}"
  else
    log_verbose "Set min to current system"
    setting_cpu_min="${cpu_min_value}"
  fi

  log_verbose "Check if we are setting turbo"
  if [ "${set_turbo_type}" -eq 1 ]; then
    log_verbose "Set turbo to arg"
    setting_cpu_turbo="${set_turbo_arg}"
  else
    log_verbose "Set turbo to current system"
    setting_cpu_turbo="${cpu_turbo}"
  fi

  log_verbose "Check if we are setting governor"
  if [ "${set_governor_type}" -eq 1 ]; then
    log_verbose "Set governor to arg"
    setting_cpu_governor="${set_governor_arg}"
  else
    log_verbose "Set governor to current system"
    setting_cpu_governor="${cpu_governor}"
  fi

  log_verbose "Check if we are setting x86_policy"
  if [ "${set_x86_policy_type}" -eq 1 ]; then
    log_verbose "Set x86_policy to arg"
    setting_x86_policy="${set_x86_policy_arg}"
  else
    log_verbose "Set x86_policy to none"
    setting_x86_policy=""
  fi

  log_verbose "Check that min is not >= max"
  if [ "${setting_cpu_min}" -ge "${setting_cpu_max}" ]; then
    log_verbose "set min to just below max"
    setting_cpu_min="$(( ${setting_cpu_max} - 1 ))"
  fi

  log_verbose "Check that max is not <= min"
  if [ "${setting_cpu_max}" -le "${setting_cpu_min}" ]; then
    log_verbose "set max to just above min"
    setting_cpu_max="$(( ${setting_cpu_min} + 1 ))"
  fi

  log_verbose "setting_cpu_max: ${setting_cpu_max}"
  log_verbose "setting_cpu_min: ${setting_cpu_min}"
  log_verbose "setting_cpu_turbo: ${setting_cpu_turbo}"
  log_verbose "setting_cpu_governor: ${setting_cpu_governor}"

  log_verbose "setting sane values first"
  root_write_governor "${sane_governor}"
  root_write_max "${sane_max}"
  root_write_min "${sane_min}"
  root_write_turbo "${sane_turbo}"

  if [ "${execution_sleep}" -eq 1 ]; then
    log_verbose "Sleep for 2 seconds requested by user"
    sleep 2
  fi

  log_verbose "Set actual values"
  root_write_governor "${setting_cpu_governor}"
  root_write_max "${setting_cpu_max}"
  root_write_min "${setting_cpu_min}"
  root_write_turbo "${setting_cpu_turbo}"
  root_write_x86_policy "${setting_x86_policy}"

  unset sane_max
  unset sane_min
  unset sane_turbo
  unset sane_governor

  unset cpu_max_freq
  unset cpu_min_freq
  unset cpu_max_value
  unset cpu_min_value
  unset cpu_turbo
  unset cpu_governor

  unset setting_cpu_max
  unset setting_cpu_min
  unset setting_cpu_turbo
  unset setting_cpu_governor
  unset setting_x86_policy
}

do_set()
{
  if [ "$(id -u)" -eq 0 ]; then
    if [ "${execution_delay}" -eq 1 ]; then
      log_verbose "Delay for 5 seconds requested by user"
      sleep 5
    fi

    root_do_set
    do_get_current
  else
    elog_quiet "You must be root."
    exit 6
  fi
}

# Check that we have intel_pstate at the intel_pstate location
has_pstate_dir()
{
  if [ -d "${const_system_intel_pstate_dir}" ]; then
    return 0
  else
    return 1
  fi
}

# Set a sanitized PATH
unset PATH
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"


# Sanity check
check_binary grep || exit 1
check_binary cat || exit 1
check_binary wc || exit 1
check_binary cut || exit 1
check_binary id || exit 1
check_binary sleep || exit 1

# System related vars
readonly const_system_power_supply_dir="/sys/class/power_supply"
readonly const_system_cpu_dir="/sys/devices/system/cpu"
readonly const_system_scaling_max_freq="${const_system_cpu_dir}/cpu0/cpufreq/scaling_max_freq"
readonly const_system_scaling_min_freq="${const_system_cpu_dir}/cpu0/cpufreq/scaling_min_freq"
readonly const_system_scaling_governor="${const_system_cpu_dir}/cpu0/cpufreq/scaling_governor"
readonly const_system_scaling_driver="${const_system_cpu_dir}/cpu0/cpufreq/scaling_driver"
readonly const_system_cpu_number="$(grep "processor" /proc/cpuinfo | wc -l)"
readonly const_system_cpu_max_freq="$(cat "${const_system_cpu_dir}/cpu0/cpufreq/cpuinfo_max_freq" )"
readonly const_system_cpu_min_freq="$(cat "${const_system_cpu_dir}/cpu0/cpufreq/cpuinfo_min_freq" )"
readonly const_system_cpu_max_value=100
readonly const_system_cpu_min_value=$(( ${const_system_cpu_min_freq} * 100 / ${const_system_cpu_max_freq} ))

# intel_pstate related vars
readonly const_system_intel_pstate_dir="${const_system_cpu_dir}/intel_pstate"
readonly const_system_intel_pstate_max="${const_system_intel_pstate_dir}/max_perf_pct"
readonly const_system_intel_pstate_min="${const_system_intel_pstate_dir}/min_perf_pct"
readonly const_system_intel_pstate_turbo="${const_system_intel_pstate_dir}/no_turbo"

# acpi-cpufreq related vars
readonly const_system_cpufreq_boost="${const_system_cpu_dir}/cpufreq/boost"

# While risky to call eval, this is one way to
# emulate the bash indirect_expansion ability
long_option=""
option_expects_argument=""
eval optind_expanded="\$${OPTIND}"
while [ -n "${optind_expanded}" ]; do
  while getopts ":HVGSp:m:n:t:g:x:crdq-:" option; do

    # Log if not long option
    if [ "${option}" != '-' ]; then
      log_verbose "parse short option: -${option} ${OPTARG}"
    fi

    # Set only on long option with arg
    if [ -n "${option_expects_argument}" ]; then
      elog_quiet "Long option --${long_option} expects argument"
      exit 2
    fi

    option_expects_argument=""
    long_option="${option_expects_argument}"
    case "${option}" in
      -)
        log_verbose "parse long option: -${option}${OPTARG}"
        case "${OPTARG}" in
          help)
            print_usage
            exit 0
            ;;
          version)
            print_version
            exit 0
            ;;
          get)
            log_verbose "Set operation mode to GET"
            mode="${const_mode_get}"
            ;;
          set)
            log_verbose "Set operation mode to SET"
            mode="${const_mode_set}"
            ;;
          plan)
            log_verbose "Attempt to set plan"
            option_expects_argument="plan"
            long_option="${option_expects_argument}"
            ;;
          max)
            log_verbose "Attempt to set max"
            option_expects_argument="max"
            long_option="${option_expects_argument}"
            ;;
          min)
            log_verbose "Attempt to set min"
            option_expects_argument="min"
            long_option="${option_expects_argument}"
            ;;
          turbo)
            log_verbose "Attempt to set turbo"
            option_expects_argument="turbo"
            long_option="${option_expects_argument}"
            ;;
          governor)
            log_verbose "Attempt to set governor"
            option_expects_argument="governor"
            long_option="${option_expects_argument}"
            ;;
          current)
            log_verbose "Set get_type to current"
            get_type="${const_get_type_current}"
            ;;
          real)
            log_verbose "Set get_type to real"
            get_type="${const_get_type_real}"
            ;;
          debug)
            log_more_verbose
            ;;
          quiet)
            log_less_verbose
            ;;
          delay)
            execution_delay=1
            ;;
          sleep)
            execution_sleep=1
            ;;
          x86)
            log_verbose "Attempt to set x86_perf_policy"
            option_expects_argument="x86"
            long_option="${option_expects_argument}"
            ;;
          *)
            # We must provide our own error message in this case
            elog_quiet "Illegal option --${OPTARG}"
            print_usage
            exit 2
            ;;
        esac
        ;;
      H)
        print_usage
        exit 0
        ;;
      V)
        print_version
        exit 0
        ;;
      G)
        log_verbose "Set operation mode to GET"
        mode="${const_mode_get}"
        ;;
      S)
        log_verbose "Set operation mode to SET"
        mode="${const_mode_set}"
        ;;
      p)
        log_verbose "Attempt to set plan"
        set_power_plan "${OPTARG}"
        ;;
      m)
        log_verbose "Attempt to set max"
        set_max "${OPTARG}"
        ;;
      n)
        log_verbose "Attempt to set min"
        set_min "${OPTARG}"
        ;;
      t)
        log_verbose "Attempt to set turbo"
        set_turbo "${OPTARG}"
        ;;
      g)
        log_verbose "Attempt to set governor"
        set_governor "${OPTARG}"
        ;;
      c)
        log_verbose "Set get_type to current"
        get_type="${const_get_type_current}"
        ;;
      r)
        log_verbose "Set get_type to real"
        get_type="${const_get_type_real}"
        ;;
      d)
        log_more_verbose
        ;;
      q)
        log_less_verbose
        ;;
      x)
        log_verbose "Attempt to set x86_perf_policy"
        set_x86 "${OPTARG}"
        ;;
      *)
        elog_quiet "Illegal option -${OPTARG}"
        print_usage
        exit 2
        ;;
    esac
  done

  # Re-establish the current OPTIND target
  eval optind_expanded="\$${OPTIND}"
  if [ -z "${optind_expanded}" ]; then
    if [ -n "${option_expects_argument}" ]; then
      elog_quiet "Long option --${long_option} expects argument"
      exit 2
    else
      break
    fi
  else
    # This is a plain arg and should be handled by one of the options which takes an argument
    handle_long_option_argument "${optind_expanded}"

    # Set back to null
    option_expects_argument=""
    long_option="${option_expects_argument}"
  fi

  # Shift the options
  shift $OPTIND
  OPTIND=1
done

case "${mode}" in
  "${const_mode_get}")
    log_verbose "MODE: GET"
    log_verbose "get_type: ${get_type}"
    do_get
    ;;
  "${const_mode_set}")
    log_verbose "MODE: SET"
    log_verbose "set_max: ${set_max_type} [${set_max_arg}]"
    log_verbose "set_min: ${set_min_type} [${set_min_arg}]"
    log_verbose "set_turbo: ${set_turbo_type} [${set_turbo_arg}]"
    log_verbose "set_governor: ${set_governor_type} [${set_governor_arg}]"
    log_verbose "set_x86: ${set_x86_policy_type} [${set_x86_policy_arg}]"
    do_set
    ;;
  *)
    print_usage
    ;;
esac

log_all "Exit: Success"
exit 0

# vim: set syntax=sh tabstop=2 softtabstop=2 shiftwidth=2 shiftround expandtab:

